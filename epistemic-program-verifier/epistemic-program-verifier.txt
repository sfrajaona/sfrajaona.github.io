-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/epistemic-program-verifier#readme</a>
@package epistemic-program-verifier
@version 0.1.0.0


-- | The module define the logical languages and everything that is needed
--   inside them
--   
--   <ul>
--   <li>agents and variables</li>
--   <li>expressions (boolean and integer expressions),</li>
--   <li>programs inside the box</li>
--   </ul>
module Logics

-- | an <a>Agent</a> is determined by its identity and the set of
--   nonobservable variables
data Agent
Agent :: Int -> [Var] -> Agent
[identity] :: Agent -> Int
[nonobs] :: Agent -> [Var]
data Var
BVar :: String -> Var
NVar :: String -> Var

-- | Function <a>varname</a> returns the name of a variable (string)
varname :: Var -> String

-- | <a>intDomain</a> gives the type for the domain for each integer
--   variable. For now <a>intDomain</a> is defined here, we cannot give it
--   at each example file because it is used to constrain quantifications
--   in the <a>Tau</a> module
type IntDomain = [Integer]

-- | returns the domain of an integer variable
intDomain :: Var -> IntDomain
data Expr a

-- | Integer constant
[I] :: Integer -> Expr Int

-- | Boolean constant
[B] :: Bool -> Expr Bool

-- | Integer variable
[IValue] :: Var -> Expr Int

-- | Boolean variable
[BValue] :: Var -> Expr Bool
[BEq] :: Expr Bool -> Expr Bool -> Expr Bool
[Xor] :: [Expr Bool] -> Expr Bool
[Or] :: [Expr Bool] -> Expr Bool
[And] :: [Expr Bool] -> Expr Bool
[Add] :: Expr Int -> Expr Int -> Expr Int
[Mul] :: Expr Int -> Expr Int -> Expr Int
[Eq] :: Expr Int -> Expr Int -> Expr Bool
[LEq] :: Expr Int -> Expr Int -> Expr Bool
type NExpr = Expr Int
type BExpr = Expr Bool

-- | The logical languages are defined here at once. The base language is a
--   is a QF first order logic where the atomic propositions are defined
--   using the expressions in <a>Expr</a>
data Formula t
[Atom] :: BExpr -> Formula t
[Neg] :: Formula t -> Formula t
[Conj] :: [Formula t] -> Formula t
[Disj] :: [Formula t] -> Formula t
[Imp] :: Formula t -> Formula t -> Formula t
[Equiv] :: Formula t -> Formula t -> Formula t

-- | Epistemic modal operator
[K] :: Agent -> Formula Modal -> Formula Modal

-- | Dynamic modal operator
[Box] :: Prog -> Formula Modal -> Formula Modal
[ForAllB] :: Int -> Formula t -> Formula t
[ExistsB] :: Int -> Formula t -> Formula t
[BSub] :: Var -> Expr Bool -> Formula Modal -> Formula Modal
[NSub] :: Var -> Expr Int -> Formula Modal -> Formula Modal

-- | <a>yvar</a> constructs a variable &lt;math&gt; for an integer i
yvar :: Int -> Var

-- | <a>uvar</a> constructs a variable &lt;math&gt; for an integer i
uvar :: Int -> Var

-- | this function choose an appropriate index &lt;math&gt; to build
--   universal quantification &lt;math&gt; from of a lambda abstracted
--   <a>FOLFormula</a>.
forAllB :: (Var -> Formula a) -> Formula a

-- | similar to <a>forAllB</a> but with existential
existsB :: (Var -> Formula a) -> Formula a
maxYBV :: Formula a -> Int
maxUBV :: Formula a -> Int
kw :: Agent -> ModalFormula -> ModalFormula
kv :: Agent -> Var -> ModalFormula
data Modal
type ModalFormula = Formula Modal
data FOL
type FOLFormula = Formula FOL
data Base
type BaseFormula = Formula Base

-- | The following is the syntax of the program.
--   
--   We explain the difference between Assert and Assume (in the context
--   programs without knowledge).
--   
--   <ul>
--   <li>Assumption. &lt;math&gt; If an assumption is false, the program
--   blocks (magic). In that case, from an initial set &lt;math&gt; of
--   states, the resulting set of state is &lt;math&gt;. Intuitively the wp
--   says that anything is true in the empty set of states.</li>
--   <li>Assertion. &lt;math&gt; If an assumption is false, the program
--   fails (error). In that case, from an initial state &lt;math&gt;, the
--   resulting set of states is error (havoc). Intuitively the sp says that
--   if &lt;math&gt; is false, any state (including error states) could
--   result from the initial state. Because any &lt;math&gt; satisfies the
--   sp.</li>
--   </ul>
--   
--   Test in dynamic logic correspond to TestAssume. <tt>TestAssume</tt>
--   below is a classical test (on FOLFormula), and its <a>sp</a> is
--   defined as a conjunction as for assumption.
--   
--   <tt>Assert</tt> and <tt>Assume</tt> below are defined for
--   ModalFormula, and their <a>wp</a> are not conjunction and implication,
--   but makes use of public announcement formula.
data Prog

-- | no operation
Skip :: Prog

-- | test with ModalFormula
Test :: ModalFormula -> Prog

-- | assignment for integer var
NAssign :: Var -> NExpr -> Prog

-- | assignment for boolean var
BAssign :: Var -> BExpr -> Prog

-- | sequential composition
Sequence :: [Prog] -> Prog

-- | nondeterministic choice
Nondet :: [Prog] -> Prog

-- | conditional with ModalFormula
IfElse :: ModalFormula -> Prog -> Prog -> Prog

-- | The function <a>wp</a> returns the weakest precondition of a modal
--   formula w.r.t a program.
wp :: ModalFormula -> Prog -> ModalFormula
sp :: ModalFormula -> Prog -> ModalFormula

-- | sub multiple variables from a list
subList :: [(Var, Expr a)] -> Formula b -> Formula b

-- | sub is the main function, takes the variable, an expression, and the
--   formula to make the substitution
sub :: Var -> Expr a -> Formula b -> Formula b

-- | <a>subNExpr</a> propagates a substitution inside a numerical/integer
--   expression
subNExpr :: Var -> NExpr -> NExpr -> NExpr

-- | <a>subBExpr</a> propagates a substitution inside a boolean expression
subBExpr :: Var -> BExpr -> BExpr -> BExpr

-- | <a>subBool</a> propagates the substitution made inside a boolean
--   expressions into a formula
subBool :: Var -> BExpr -> Formula a -> Formula a

-- | <a>subNum</a> propagates the substitution inside integer expressions
--   into a formula
subNum :: Var -> NExpr -> Formula a -> Formula a

-- | <a>noDisj</a> eliminates disjunction, necessary for <tt>noAnn</tt>
noDisj :: Formula a -> Formula a
instance GHC.Classes.Ord Logics.Var
instance GHC.Classes.Eq Logics.Var


-- | The main program <a>toSBV</a> takes the list of variables, the
--   constraint formula (a <a>FOLFormula</a>), and the target formula (the
--   translation of a <a>ModalFormula</a> into a <a>FOLFormula</a>)
module ToSBV

-- | <a>toSBV</a> takes a constraint &lt;math&gt; (in <a>FOLFormula</a>)
--   and target formula in <a>FOLFormula</a>. The target formula is usually
--   the translation of a <a>ModalFormula</a> &lt;math&gt; via the
--   <a>Tau</a> module. Both formulas are converted into SBV formula.
--   Variables are converted into SBV symbolic variables (<tt>freeInts</tt>
--   and <tt>freeBools</tt>)
toSBV :: [Var] -> FOLFormula -> FOLFormula -> Predicate

-- | toSymb: convert a formula into SBV formula, recall `type State = (Map
--   Var Bool, Map Var Integer)`, here we make the state to take a symbolic
--   value to apply the SMT solver
toSymb :: (Map Var SBool, Map Var SInteger) -> FOLFormula -> SBool

-- | toSymbBExpr: convert a boolean expression in BExpr into SBV SBool.
--   variables in the BExpr are replaced by SBV variables created in
--   bmapsools
toSymbBExpr :: (Map Var SBool, Map Var SInteger) -> BExpr -> SBool

-- | toSymbNExpr: convert a numerical expression in NExpr into SBV SInteger
--   variables in the NExpr are replaced by SBV variables created in
--   nmapsnt
toSymbNExpr :: Map Var SInteger -> NExpr -> SInteger


-- | Printing formulas with quantifiers is not yet implemented. It is a bit
--   difficult because we use function for quantification to avoid variable
--   binding problems.
module ToString
precedence :: Formula t -> Int
precedenceNE :: NExpr -> Int

-- | The main function takes any formula (<a>FOLFormula</a> or
--   <a>ModalFormula</a>) and returns a string. The output string is
--   formatted to be parsable by Python. The plan is to use SymPy to remove
--   redundant tautologies. The elimination of the annouce logical operator
--   exploded the size of the formula.
toString :: Formula a -> String
toStringPrec :: Int -> Formula a -> String
separateWithCommas :: [String] -> String
instance GHC.Show.Show (Logics.Formula a)
instance GHC.Show.Show Logics.Var
instance GHC.Show.Show (Logics.Expr a)
instance GHC.Show.Show Logics.Prog


module Translation

-- | The translation function <tt>tau</tt> takes the constraint formula in
--   <a>FOLFormula</a> and a target formula in <a>ModalFormula</a>
--   
--   <tt>(NSub v e alpha)</tt> and <tt>(BSub v e alpha)</tt> are the
--   implementation of <tt>alpha[v/e]</tt> we enumerate all the cases for a
--   formula with <tt>alpha[v/e]</tt> <tt>K_A alpha[v/e]</tt> is the
--   speciall one, for an atom <tt>alpha[v/e]</tt> becomes a simple
--   substitution Some cases are not covered yet, e.g.,
--   <tt>([rho]alpha)[v/e]</tt> Some cases are not covered yet, e.g.,
--   <tt>(alpha[v<i>e])[v'</i>e']</tt>
tau :: FOLFormula -> Formula a -> FOLFormula


-- | <tt>n</tt> agents dine at a round table [Chaum, 1988]. The dinner may
--   have been paid by their employer (the NSA), or by one of the agents.
--   They execute a protocol to reveal whether one of the agents paid, but
--   without revealing which one. The protocol supplies each pair of
--   adjacent agents with a random coin, which can be observed only by that
--   pair. Each agent announces the result of XORing three Booleans: the
--   two coins observable by her and the status of whether she paid for the
--   dinner. The XOR of all announcements is proven to be equal to the
--   disjunction of whether any agent paid.
module ExampleDiningCryptographers

-- | <tt>ag i</tt> characterised by its identity <tt>i</tt> and its
--   nonobservable variables
ag :: Int -> Agent

-- | all variables
allVars :: [Var]

-- | observability function, &lt;math&gt; observes &lt;math&gt;,
obs :: Int -> [Var]

-- | boolean variable &lt;math&gt;
varx :: Var

-- | boolean expression x
x :: BExpr

-- | boolean variable &lt;math&gt; coin flip between agent i and agent i-1
varc :: Int -> Var

-- | boolean variable &lt;math&gt; agent i paid
varp :: Int -> Var

-- | boolean expression &lt;math&gt;
p :: Int -> BExpr

-- | boolean expression &lt;math&gt;
c :: Int -> BExpr

-- | &lt;math&gt; or &lt;math&gt; the constraint on the inital states:
--   "that all agents knows that at most one agent paid"
phi :: FOLFormula

-- | the boolean expression to be assigned to &lt;math&gt; in the algorithm
bexprDC :: BExpr

-- | the DC algorithm as an assignment to &lt;math&gt;
progDC :: Prog

-- | the number of agents
n :: Int
noonepaid :: ModalFormula
dontknowwhopaid :: Agent -> ModalFormula
alpha1 :: ModalFormula

-- | an example of Modal Formula to be verified at the end of the DC
--   algorithm
alpha2 :: ModalFormula

-- | an example of Modal Formula to be verified at the end of the DC
--   algorithm
alpha3 :: ModalFormula

-- | proving &lt;math&gt;
dcAlpha1 :: IO ThmResult

-- | proving &lt;math&gt;
dcAlpha2 :: IO ThmResult

-- | proving &lt;math&gt; (should be falsified)
--   
--   DC with &lt;math&gt; as in IJCAI paper
--   
--   <pre>
--   &gt;&gt;&gt; prove dcAlpha3
--   Falsifiable. Counter-example:
--     x  = False :: Bool
--     c0 = False :: Bool
--     c1 = False :: Bool
--     p0 = False :: Bool
--     p1 = False :: Bool
--   </pre>
dcAlpha3 :: IO ThmResult
