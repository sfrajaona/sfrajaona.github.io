-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/epistemic-program-verifier#readme</a>
@package epistemic-program-verifier
@version 0.1.0.0


-- | The module define the logical languages and everything that is needed
--   inside them
--   
--   <ul>
--   <li>agents and variables</li>
--   <li>expressions (boolean and integer expressions),</li>
--   <li>programs inside the box</li>
--   </ul>
module Logics

-- | an <a>Agent</a> is determined by its identity and the set of
--   nonobservable variables
data Agent
Agent :: Int -> [Var] -> Agent
[identity] :: Agent -> Int
[nonobs] :: Agent -> [Var]
data Var
BVar :: String -> Var
NVar :: String -> Var

-- | Function <a>varname</a> returns the name of a variable (string)
varname :: Var -> String

-- | <a>intDomain</a> gives the type for the domain for each integer
--   variable. For now <a>intDomain</a> is defined here, we cannot give it
--   at each example file because it is used to constrain quantifications
--   in the <a>Tau</a> module
type IntDomain = [Integer]

-- | returns the domain of an integer variable
intDomain :: Var -> IntDomain
data Expr a

-- | Integer constant
[I] :: Integer -> Expr Int

-- | Boolean constant
[B] :: Bool -> Expr Bool

-- | Integer variable
[IValue] :: Var -> Expr Int

-- | Boolean variable
[BValue] :: Var -> Expr Bool
[Xor] :: [Expr Bool] -> Expr Bool
[Or] :: [Expr Bool] -> Expr Bool
[And] :: [Expr Bool] -> Expr Bool
[Add] :: Expr Int -> Expr Int -> Expr Int
[Mul] :: Expr Int -> Expr Int -> Expr Int
[Eq] :: Expr Int -> Expr Int -> Expr Bool
[LEq] :: Expr Int -> Expr Int -> Expr Bool
type NExpr = Expr Int
type BExpr = Expr Bool

-- | The logical languages are defined here at once. The base language is a
--   is a QF first order logic where the atomic propositions are defined
--   using the expressions in <a>Expr</a>
data Formula t
[Atom] :: BExpr -> Formula t
[Neg] :: Formula t -> Formula t
[Conj] :: [Formula t] -> Formula t
[Disj] :: [Formula t] -> Formula t
[Imp] :: Formula t -> Formula t -> Formula t
[Equiv] :: Formula t -> Formula t -> Formula t

-- | Epistemic modal operator
[K] :: Agent -> Formula Modal -> Formula Modal

-- | Public announcement operator
[Announce] :: Formula Modal -> Formula Modal -> Formula Modal

-- | Dynamic modal operator
[Box] :: Prog -> Formula Modal -> Formula Modal
[Forall] :: (Expr Bool -> Formula FOL) -> Formula FOL
[Exists] :: (Expr Bool -> Formula FOL) -> Formula FOL
[ForallInt] :: IntDomain -> (Expr Int -> Formula FOL) -> Formula FOL
[ExistsInt] :: IntDomain -> (Expr Int -> Formula FOL) -> Formula FOL
kw :: Agent -> ModalFormula -> ModalFormula
kv :: Agent -> Var -> ModalFormula
data Modal
type ModalFormula = Formula Modal
data FOL
type FOLFormula = Formula FOL
data Base
type BaseFormula = Formula Base

-- | The following is the syntax of the program.
--   
--   We explain the difference between Assert and Assume (in the context
--   programs without knowledge).
--   
--   <ul>
--   <li>Assumption. &lt;math&gt; If an assumption is false, the program
--   blocks (magic). In that case, from an initial set &lt;math&gt; of
--   states, the resulting set of state is &lt;math&gt;. Intuitively the wp
--   says that anything is true in the empty set of states.</li>
--   <li>Assertion. &lt;math&gt; If an assumption is false, the program
--   fails (error). In that case, from an initial state &lt;math&gt;, the
--   resulting set of states is error (havoc). Intuitively the sp says that
--   if &lt;math&gt; is false, any state (including error states) could
--   result from the initial state. Because any &lt;math&gt; satisfies the
--   sp.</li>
--   </ul>
--   
--   Test in dynamic logic correspond to TestAssume. <a>TestAssume</a>
--   below is a classical test (on FOLFormula), and its <a>sp</a> is
--   defined as a conjunction as for assumption.
--   
--   <a>Assert</a> and <a>Assume</a> below are defined for ModalFormula,
--   and their <a>wp</a> are not conjunction and implication, but makes use
--   of public announcement formula.
data Prog

-- | no operation
Skip :: Prog

-- | assertion with ModalFormula
Assert :: ModalFormula -> Prog

-- | assumption with ModalFormula
Assume :: ModalFormula -> Prog

-- | assertion with FOLFormula
TestAssert :: FOLFormula -> Prog

-- | assumption with FOLFormula
TestAssume :: FOLFormula -> Prog

-- | assignment for integer var
NAssign :: Var -> NExpr -> Prog

-- | assignment for boolean var
BAssign :: Var -> BExpr -> Prog

-- | sequential composition
Sequence :: [Prog] -> Prog

-- | nondeterministic choice
Nondet :: [Prog] -> Prog

-- | conditional with ModalFormula
IfElse :: ModalFormula -> Prog -> Prog -> Prog

-- | conditional with FOLFormula
IfElseFO :: FOLFormula -> Prog -> Prog -> Prog

-- | The function <a>wp</a> returns the weakest precondition of a modal
--   formula w.r.t a program. The <a>wp</a> of assumption, assertion,
--   assignment and conditional make use of a public announcement formula.
--   The running program is publicly known.
wp :: ModalFormula -> Prog -> ModalFormula
sp :: FOLFormula -> Prog -> FOLFormula

-- | sub multiple variables from a list
subList :: [(Var, Expr a)] -> Formula b -> Formula b

-- | sub is the main function, takes the variable, an expression, and the
--   formula to make the substitution
sub :: Var -> Expr a -> Formula b -> Formula b

-- | <a>subNExpr</a> propagates a substitution inside a numerical/integer
--   expression
subNExpr :: Var -> NExpr -> NExpr -> NExpr

-- | <a>subBExpr</a> propagates a substitution inside a boolean expression
subBExpr :: Var -> BExpr -> BExpr -> BExpr

-- | <a>subBool</a> propagates the substitution made inside a boolean
--   expressions into a formula
subBool :: Var -> BExpr -> Formula a -> Formula a

-- | <a>subNum</a> propagates the substitution inside integer expressions
--   into a formula
subNum :: Var -> NExpr -> Formula a -> Formula a

-- | <a>noAnn</a> eliminates the logical operator Announce
noAnn :: ModalFormula -> ModalFormula

-- | <a>noDisj</a> eliminates disjunction, necessary for <a>noAnn</a>
noDisj :: ModalFormula -> ModalFormula

-- | Utility function star. Removes equality (or equivalence) with
--   variables inside a set.
star :: [Var] -> FOLFormula -> FOLFormula
instance GHC.Classes.Ord Logics.Var
instance GHC.Show.Show Logics.Var
instance GHC.Classes.Eq Logics.Var
instance GHC.Show.Show Logics.Agent


module StateInitialisation

-- | Utility functions for state initialisation
type State = (Map Var Bool, Map Var Integer)

-- | function that converts a mapping (Variable,Value) into equality
--   (Variable=Value)
toFormulaMap :: Var -> State -> FOLFormula

-- | function that converts a state (list of mapping) into a conjunction of
--   equality i.e., defines phi(i) = /{var_1=val_1(i) , var2=val_2(i), ...}
toFormula :: [Var] -> State -> FOLFormula

-- | evaluate a formula at a state, necessary for restricting the initial
--   states with phi
eval :: State -> FOLFormula -> Bool

-- | evalBExpr: convert a boolean expression in BExpr into Bool.
evalBExpr :: State -> BExpr -> Bool

-- | evalNExpr: convert a numerical expression in NExpr into Integer
evalNExpr :: Map Var Integer -> NExpr -> Integer


-- | The main program <a>toSBV</a> takes the list of variables, the
--   constraint formula (a <a>FOLFormula</a>), and the target formula (the
--   translation of a <a>ModalFormula</a> into a <a>FOLFormula</a>)
module ToSBV

-- | <a>toSBV</a> takes a constraint &lt;math&gt; (in <a>FOLFormula</a>)
--   and target formula in <a>FOLFormula</a>. The target formula is usually
--   the translation of a <a>ModalFormula</a> &lt;math&gt; via the
--   <a>Tau</a> module. Both formulas are converted into SBV formula.
--   Variables are converted into SBV symbolic variables (<tt>freeInts</tt>
--   and <tt>freeBools</tt>)
toSBV :: [Var] -> FOLFormula -> FOLFormula -> Predicate

-- | toSymb: convert a formula into SBV formula
toSymb :: (Map Var SBool, Map Var SInteger) -> FOLFormula -> SBool

-- | toSymbBExpr: convert a boolean expression in BExpr into SBV SBool.
--   variables in the BExpr are replaced by SBV variables created in
--   freeBools
toSymbBExpr :: (Map Var SBool, Map Var SInteger) -> BExpr -> SBool

-- | toSymbNExpr: convert a numerical expression in NExpr into SBV SInteger
--   variables in the NExpr are replaced by SBV variables created in
--   freeInt
toSymbNExpr :: Map Var SInteger -> NExpr -> SInteger


-- | Printing formulas with quantifiers is not yet implemented. It is a bit
--   difficult because we use function for quantification to avoid variable
--   binding problems.
module ToString

-- | The main function takes any formula (<a>FOLFormula</a> or
--   <a>ModalFormula</a>) and returns a string. The output string is
--   formatted to be parsable by Python. The plan is to use SymPy to remove
--   redundant tautologies. The elimination of the annouce logical operator
--   exploded the size of the formula.
toString :: Formula a -> String


module Translation

-- | The translation function <tt>tau</tt> takes the constraint formula in
--   <a>FOLFormula</a> and a target formula in <a>ModalFormula</a>
tau :: FOLFormula -> Formula a -> FOLFormula

-- | tauNew is defined by Theorem 3.3. Here it takes as argument a list
--   &lt;math&gt; of the formulas defining the initial states
tauNew :: FOLFormula -> [FOLFormula] -> ModalFormula -> FOLFormula

-- | The new translation take an extra argument, the FOL formula
--   &lt;math&gt;, i.e, &lt;math&gt; of a state
tauS :: FOLFormula -> FOLFormula -> ModalFormula -> FOLFormula


module ExampleMrSumMrProduct
mrSmrP :: IO AllSatResult


-- | <tt>n</tt> agents dine at a round table [Chaum, 1988]. The dinner may
--   have been paid by their employer (the NSA), or by one of the agents.
--   They execute a protocol to reveal whether one of the agents paid, but
--   without revealing which one. The protocol supplies each pair of
--   adjacent agents with a random coin, which can be observed only by that
--   pair. Each agent announces the result of XORing three Booleans: the
--   two coins observable by her and the status of whether she paid for the
--   dinner. The XOR of all announcements is proven to be equal to the
--   disjunction of whether any agent paid.
module ExampleDiningCryptographers

-- | <tt>ag i</tt> characterised by its identity <tt>i</tt> and its
--   nonobservable variables
ag :: Int -> Agent

-- | all variables
allVars :: [Var]

-- | observability function, &lt;math&gt; observes &lt;math&gt;,
obs :: Int -> [Var]

-- | boolean variable &lt;math&gt;
varx :: Var

-- | boolean expression x
x :: BExpr

-- | boolean variable &lt;math&gt; coin flip between agent i and agent i-1
varc :: Int -> Var

-- | boolean variable &lt;math&gt; agent i paid
varp :: Int -> Var

-- | boolean expression &lt;math&gt;
p :: Int -> BExpr

-- | boolean expression &lt;math&gt;
c :: Int -> BExpr

-- | &lt;math&gt; or &lt;math&gt; the constraint on the inital states:
--   "that all agents knows that at most one agent paid"
phi :: FOLFormula

-- | the boolean expression to be assigned to &lt;math&gt; in the algorithm
bexprDC :: BExpr

-- | the DC algorithm as an assignment to &lt;math&gt;
progDC :: Prog

-- | the number of agents
n :: Int

-- | an example of Modal Formula to be verified at the end of the DC
--   algorithm
alpha2 :: ModalFormula

-- | an example of Modal Formula to be verified at the end of the DC
--   algorithm
alpha3 :: ModalFormula

-- | proving &lt;math&gt;
dcAlpha2 :: IO ThmResult

-- | proving &lt;math&gt; (should be falsified)
--   
--   DC with &lt;math&gt; as in IJCAI paper
--   
--   <pre>
--   &gt;&gt;&gt; prove dcAlpha3
--   Falsifiable. Counter-example:
--     x  = False :: Bool
--     c0 = False :: Bool
--     c1 = False :: Bool
--     p0 = False :: Bool
--     p1 = False :: Bool
--   </pre>
dcAlpha3 :: IO ThmResult


-- | Cheryl's birthday is one of 10 possible dates:
--   
--   <pre>
--   May           15  16          19
--   June                  17  18  
--   July      14      16      
--   August    14  15      17    
--   </pre>
--   
--   Cheryl tells Albert the month and tells Bernard the day. Then proceeds
--   the following announcement.
--   
--   <ul>
--   <li><a>annAlbert1</a>: Albert does not know the day and Albert knows
--   that Bernard does not know the month</li>
--   <li><a>annBernard</a>: Bernard annouces he knows the month now</li>
--   <li><a>annAlbert2</a>: Albert annouces he knows the day now</li>
--   </ul>
--   
--   The couples (<tt>day</tt>,<tt>month</tt>) that satisfy the puzzle is
--   computed with the functions <a>cherylsBirthday</a>. Simplified version
--   of the puzzle are given in <a>cherylsBirthday2</a> and
--   <a>cherylsBirthday3</a>.
--   
--   In the original version of the puzzle, in the second announcement
--   <a>annBernard</a>, Bernard announces that Bernard it didn't know the
--   month before Albert's announcement. This cannot be captured by the
--   logic. The original version and our version yields the same unique
--   solution.
module ExampleBirthdayCheryl

-- | cherylsBirthday find the satisfiability set for the puzzle. This
--   function uses <a>SBV</a> to check satisfiability set of the Box-Modal
--   <a>Logic</a> formula <tt>[<a>annAlbert1</a>?; <a>annBernard</a>?;
--   <a>annAlbert2</a>?] True</tt> (or equivalently
--   <tt>[<a>annAlbert1</a>?; <a>annBernard</a>?] kv albert day</tt>). The
--   formula is first translated into First-Order Logic with <a>Tau</a>
--   
--   <pre>
--   &gt;&gt;&gt; cherylsBirthday
--       Solution #1:
--         month =  7 :: Integer
--         day   = 16 :: Integer
--       This is the only solution.
--   </pre>
--   
--   The actual solution of the puzzle
cherylsBirthday :: IO AllSatResult

-- | <tt>cherylsBirthday2</tt> find the satisfiability set for a simplified
--   puzzle with <tt>ProgC2 = (day = 19)?</tt>, check if <tt>[ProgC2]
--   KV_bernard month</tt>
--   
--   <pre>
--   &gt;&gt;&gt; CherylsBirthday2
--    month =  5 :: Integer
--    day   = 19 :: Integer
--    This is the only solution.
--   </pre>
--   
--   The actual solution of this instance of the puzzle
cherylsBirthday2 :: IO AllSatResult

-- | <tt>cherylsBirthday3</tt> find the satisfiability set for a simplified
--   puzzle with <tt>ProgC3 = (day = 17)?</tt>, check if <tt>[ProgC3]
--   KV_bernard month</tt>
--   
--   <pre>
--   &gt;&gt;&gt; CherylsBirthday3
--   No solutions found             
--   </pre>
--   
--   Because there are two possible months with <tt>day=17</tt> and bernard
--   cannot distinguish them.
cherylsBirthday3 :: IO AllSatResult

-- | cherylsBirthdayOriginal the announcement of Bernard, also include that
--   he didn't know the month before the announcement of Albert
cherylsBirthdayOriginal :: IO AllSatResult

-- | First announcement by Albert <tt>kv x</tt> means knowing the value of
--   <tt>x</tt>, defined as a disjunction in <a>Logics</a>
annAlbert1 :: Formula Modal
annBernard :: ModalFormula
annAlbert2 :: ModalFormula
